# ╔═════════════════════════════════════════════════════════════════════════╗
# ║        Programming school "School-21" students work project:            ║
# ║═════════════════════════════════════════════════════════════════════════║
# ║            Methods of the CPP2_s21_containers project, which            ║
# ║            implements a library for working with containers.            ║
# ║                                                                         ║
# ║                                    copyright School-21 (c) 2024         ║
# ║                           makefile by student Mikhail Sokolskiy         ║
# ╚═════════════════════════════════════════════════════════════════════════╝


###############################################################################
##                                                                           ##
##                           К О М П И Л Я Т О Р                             ##
##                                                                           ##
###############################################################################


# Константа имени операционной системы
OS:=$(shell uname -s)

# Выбор компилятора
ifeq ($(OS), Windows_NT)
	CXX = cl
else
	ifeq ($(OS), Darwin)
		CXX = clang++
	else
		CXX = g++
	endif
endif


# Атрибуты компиляции для компилятора
CXXFLAGS=-std=c++17 -g \
		-Wall \
		-Wextra \
		--coverage \
		-Werror



# ╔═════════════════════════════════════════════════════════════════════════╗
# ║ Служебные переменные для сборки Google-тестов и отчёта Gcov             ║
# ╚═════════════════════════════════════════════════════════════════════════╝

# Атрибуты компиляции, необходимые для библиотеки gtest. Разберём подробнее:
#  -lgtest — этот флаг говорит компилятору линковать программу с библиотекой gtest.
#              Здесь:
#         -l — это флаг, который указывает компилятору линковать с определенной библиотекой.
#      gtest — это имя библиотеки Google Test. Когда компилятор видит этот флаг, он ищет
#              файл библиотеки с именем libgtest.a (или .so или .dylib в случае динамической
#              библиотеки) в директориях, указанных в -L флаге (или в системных каталогах).
#  -lgtest_main — указывает на линковку с библиотекой libgtest_main.a (по сути это просто
#                 main файл, встроенный в gtest, который позволяет нам не делать свой main в тестах)
#  -pthread или -lpthread (второй менее предпочтителен, так как уменьшает возможности правильной
#           настройки компилятора) — включает поддержку многопоточности, что необходимо для gtest

GTEST_ATTR=-lgtest -lgtest_main -pthread



# Путь, где лежит библиотека (в нашем случае это путь к файлу libgtest.a библиотеки gtest)
# Обязательно прописывать локальный путь в виде атрибута -L/ваш/путь/к/библиотеке в случае,
# если путь к библиотеке не занесён в переменную окружения LIBRARY_PATH вашей ОС
# (для добавления в переменную окружения, вставьте строку:
# export LIBRARY_PATH="/ваш/путь/к/библиотеке:$LIBRARY_PATH"
# в файле конфигурации ~/.zshrc или ~/.bash_profile или ~/.bashrc)

LIBRARY=


# Путь, где лежат заголовочные файлы (.h, .hpp и др.) библиотеки (в нашем случае где лежит gtest.h)
# Обязательно прописывать локальный путь в виде атрибута -I/ваш/путь/к/хедерам в случае,
# если путь к заголовочникам не занесён в переменную окружения CPLUS_INCLUDE_PATH вашей ОС
# (для добавления в переменную окружения, вставьте строку:
# export CPLUS_INCLUDE_PATH="/ваш/путь/к/хедерам/библиотеки:$CPLUS_INCLUDE_PATH"
# в файле конфигурации ~/.zshrc или ~/.bash_profile или ~/.bashrc)

INCLUDES=


# переменная GCR нужна для создания gcov-report. Для g++ оставить пустым. Для clang++
# инициализируется другой строкой ниже в условии
GCR=

ifeq ($(OS), Darwin)
	GCR=--gcov-executable "llvm-cov gcov" --exclude '.*\.cc$$' --exclude "s21_containers.h"
endif


# ╔═════════════════════════════════════════════════════════════════════════╗
# ║ Переменные для компиляции                                               ║
# ╚═════════════════════════════════════════════════════════════════════════╝

# Переменные основных рабочих директорий проекта
PATH_TO_OBJ=objects/
PATH_TO_TESTS=TESTS/
PATH_TO_SUP=SUPPORT_FUNCTIONS/
PATH_TO_MAIN=MAIN_FUNCTIONS/
COV_REPORT=REPORT/

# Переменная имени файла статической библиотеки
LIB_NAME=s21_containers.a

# Переменная имени исполняемого файла запуска всех автотестов
EXEC_T=unit_tests


# ╔═════════════════════════════════════════════════════════════════════════╗
# ║ Списки файлов для компиляции                                            ║
# ╚═════════════════════════════════════════════════════════════════════════╝

# Список всех .cc файлов в папках SUPPORT_FUNCTIONS и MAIN_FUNCTIONS
SRC=$(wildcard $(PATH_TO_SUP)*.cc) $(wildcard $(PATH_TO_MAIN)*.cc)

# Составление списка .о файлов и сохранение его в переменной OBJ.
# Сами .o файлы ещё при этом не созданы! Создаётся только их список.
# (Функция patsubst берет список всех .сс файлов из папок SUPPORT_FUNCTIONS
# и MAIN_FUNCTIONS(из переменной SRC), подменяет их расширения на .о
# и добавляет спереди каждому папку objects/
# и получается список: objects/MAIN_FUNCTIONS/s21_list.o ...)
OBJ=$(patsubst %.cc, $(PATH_TO_OBJ)%.o, $(SRC))

# Список .cc файлов автотестов с путём (TESTS/s21_list_test.cc ...)
SRC_T=$(wildcard $(PATH_TO_TESTS)*.cc)

# Список .o файлов автотестов c путём в папку
# объектов (objects/TESTS/s21_list_test.o ...)
# Самих файлов .o пока ещё нет!
OBJ_T=$(patsubst %.cc, $(PATH_TO_OBJ)%.o, $(SRC_T))



###############################################################################
##                                                                           ##
##                      О С Н О В Н Ы Е   Ц Е Л И                            ##
##                                                                           ##
###############################################################################

# ╔═════════════════════════════════════════════════════════════════════════╗
# ║ Комплексная цель all                                                    ║
# ╚═════════════════════════════════════════════════════════════════════════╝
all: $(LIB_NAME) test gcov_report
	@echo "\n$(BRIGHT_ORANGE) $(STAR) Все цели выполнены $(STAR) $(RESET)\n"


# ╔═════════════════════════════════════════════════════════════════════════╗
# ║ Создание статической библиотеки                                         ║
# ╚═════════════════════════════════════════════════════════════════════════╝
# Перед выполнением цели создания библиотеки сначала происходит вызов
# переменной OBJ, которая содержит в себе список объектных .o файлов
# (objects/MAIN_FUNCTIONS/s21_list.o ...) для функций из папок
# SUPPORT_FUNCTIONS и MAIN_FUNCTIONS.
# Когда утилита make считывает переменную OBJ, она видит по списку файлов,
# что они соответствуют служебной цели $(PATH_TO_OBJ)%.o, тогда утилита make
# для каждого файла из этого списка запускает выполнение этой цели
# $(PATH_TO_OBJ)%.o. Цель выпоняется, компилируя из .cc файлы .o
# Когда список заканчивается, происходит запуск самой цели создания библиотеки.
# Утилита ar собирает библиотеку из файлов .o, которые получает из списка
# переменной OBJ
$(LIB_NAME): $(OBJ)
	@echo "\n $(WHITE)$(ARROW) Линковка статической библиотеки...$(RESET)"
	@ar rcs $@ $(OBJ) 2>/dev/null
	@ranlib $@ 2>/dev/null
	@echo "$(BLACK_WHITE) $(CHECK) Библиотека s21_containers.a собрана $(RESET)\n"


# ╔═════════════════════════════════════════════════════════════════════════╗
# ║ Компиляция и запуск тестов                                              ║
# ╚═════════════════════════════════════════════════════════════════════════╝
test: $(OBJ_T) $(LIB_NAME)
	@echo "\n$(GREEN)$(ARROW) Запуск тестов...$(RESET)\n"
	@$(CXX) $(CXXFLAGS) $(LIB_NAME) $(OBJ_T) -o $(PATH_TO_TESTS)$(EXEC_T) $(INCLUDES) $(LIBRARY) $(GTEST_ATTR) 2>/dev/null
	@$(PATH_TO_TESTS)./$(EXEC_T) 2>/dev/null
# | tee $(PATH_TO_TESTS)$(EXEC_T).txt
	@echo "\n$(GREEN) $(CHECK) Тесты завершены  $(RESET)\n"
# @echo "$(GREEN)   Файл тестов находится по адресу '$(PATH_TO_TESTS)$(EXEC_T).txt' $(RESET)\n"


# ╔═════════════════════════════════════════════════════════════════════════╗
# ║ Создание отчета покрытия Gcov. Файлы тестов исключаются                 ║
# ╚═════════════════════════════════════════════════════════════════════════╝
# 				установка: pip install git+https://github.com/gcovr/gcovr.git
#
gcov_report:
	@echo " \n $(BLUE)  Создание отчета покрытия...$(RESET)"
	@gcovr $(GCR) \
	--html-details $(COV_REPORT)gcov_report.html \
	--html-theme github.dark-blue \
	--exclude "$(PATH_TO_TESTS)*" 
# 
#  > /dev/null 2>/dev/null
# --decisions
	@echo "$(BLUE) $(CHECK) Отчет покрытия создан $(RESET)\n"
	@if command -v xdg-open > /dev/null; then \
        xdg-open $(COV_REPORT)gcov_report.html; \
    elif command -v open > /dev/null; then \
        open $(COV_REPORT)gcov_report.html; \
    else \
        echo "Не удалось открыть браузер. Пожалуйста, откройте '$(COV_REPORT)gcov_report.html' вручную."; \
    fi


# ╔═════════════════════════════════════════════════════════════════════════╗
# ║ Удаление библиотеки и директорий objects/ и REPORT/                     ║
# ╚═════════════════════════════════════════════════════════════════════════╝
clean:
	@echo "\n$(RED_ALERT)   Очистка...$(RESET)"
	@rm -rf \
	$(PATH_TO_OBJ) \
	$(COV_REPORT) \
	$(PATH_TO_TESTS)./$(EXEC_T)* \
	$(LIB_NAME)
	@echo "$(RED_ALERT) $(CHECK) Очистка завершена $(RESET)\n"




###############################################################################
##                                                                           ##
##                  С Л У Ж Е Б Н Ы Е    О П Е Р А Ц И И                     ##
##                                                                           ##
###############################################################################


# ╔═════════════════════════════════════════════════════════════════════════╗
# ║ Служебная цель. Правило компиляции объектных файлов из исходных .cc     ║
# ║ и запись их в директорию objects/ и соответствующие им поддиректории    ║
# ╚═════════════════════════════════════════════════════════════════════════╝
# Левая часть: $(PATH_TO_OBJ)%.o указывает шаблон для объектных файлов,
# где % представляет собой подстановочный знак, который может соответствовать
# любому тексту.
# Правая часть: %.cc указывает шаблон для исходных файлов, где % должен
# соответствовать тому же тексту, что и в левой части.
# Эта цель говорит make, что каждый файл с расширением .o в папке $(PATH_TO_OBJ)
# может быть создан из соответствующего файла с расширением .cc
# Автоматические переменные:
# $@ - имя цели  ( слева : )
# $< - имя первой зависимости ( : справа )
# Зависимость - это цель, которая обязана выполниться до старта текущей
# Пример:
# target: dependency1 dependency2 dependency2 с командой
# 	$(CC) -o $@ $<
# здесь $< = dependency1

$(PATH_TO_OBJ)%.o: %.cc
	@echo "$(GREY)  $<...$(RESET)"
	@$(CXX) $(CXXFLAGS) -c $< -o $@
	@echo "$(WHITE)$(CHECK) $@$(RESET)"



# ╔═════════════════════════════════════════════════════════════════════════╗
# ║ Создание директорий объектов.                                           ║
# ║ Служебная команда, выполняемая всегда при запуске makefile до целей     ║
# ╚═════════════════════════════════════════════════════════════════════════╝
$(shell \
	mkdir -p $(COV_REPORT) \
			 $(PATH_TO_OBJ)$(PATH_TO_TESTS) \
			 $(PATH_TO_OBJ)$(PATH_TO_SUP) \
			 $(PATH_TO_OBJ)$(PATH_TO_MAIN))


# ╔═════════════════════════════════════════════════════════════════════════╗
# ║ Подключение дополнительных целей и операций.                            ║
# ║                                                                         ║
# ║  develop.mk - цели для рабочих версий программ и ручных тестов          ║
# ║      git.mk - записи/считывания изменений gitlab                        ║
# ║ clearmac.mk - чистка кеша на школьном маке                              ║
# ║   colors.mk - цвета консоли и символьная графика                        ║
# ╚═════════════════════════════════════════════════════════════════════════╝

include MAKEFILES/develop.mk
include MAKEFILES/git.mk
include MAKEFILES/clearmac.mk
include MAKEFILES/colors.mk


# Убираем конфликт названия целей с названиями файлов
.PHONY: all gcov_report test clean $(LIB_NAME)


# ###############################################################################
# ##                                                                           ##
# ##                           К О М П И Л Я Т О Р                             ##
# ##                                                                           ##
# ###############################################################################


# # Константа имени операционной системы
# OS:=$(shell uname -s)

# # Выбор компилятора
# ifeq ($(OS), Windows_NT)
# 	CXX = cl
# else
# 	ifeq ($(OS), Darwin)
# 		CXX = clang++
# 	else
# 		CXX = g++
# 	endif
# endif


# # Атрибуты компиляции для компилятора
# CFLAGS=-std=c++17 -g \
# 		-Wall \
# 		-Wextra \
# 		--coverage \
# 		-Werror


# # ╔═════════════════════════════════════════════════════════════════════════╗
# # ║ Служебные переменные для отчёта и тестов                                ║
# # ╚═════════════════════════════════════════════════════════════════════════╝

# # переменная нужна для gcov-report. Для g++ оставить пустым. Для clang++ инициализируется другой строкой
# GCR=
# LIBS=-lgtest -lgtest_main -lpthread


# ifeq ($(OS), Darwin)
# # CFLAGS+=$(shell pkg-config --cflags gtest)
# # LIBS+=-lgtest -lgtest_main -lpthread
# # $(shell pkg-config --libs gtest)
# 	#GCR=--gcov-executable "llvm-cov gcov" --exclude '.*\.cc$$' --exclude "s21_containers.h"
# endif


# # ╔═════════════════════════════════════════════════════════════════════════╗
# # ║ Переменные для компиляции                                               ║
# # ╚═════════════════════════════════════════════════════════════════════════╝

# # Переменные директорий
# PATH_TO_OBJ=objects/
# PATH_TO_TESTS=TESTS/
# PATH_TO_SUP=SUPPORT_FUNCTIONS/
# PATH_TO_MAIN=MAIN_FUNCTIONS/
# COV_REPORT=REPORT/

# # Переменная имени файла статической библиотеки
# LIB_NAME=s21_containers.a

# # Переменная имени исполняемого файла запуска всех автотестов
# EXEC_T=unit_tests


# # ╔═════════════════════════════════════════════════════════════════════════╗
# # ║ Списки файлов для компиляции                                            ║
# # ╚═════════════════════════════════════════════════════════════════════════╝

# # Список всех .cc файлов в папках SUPPORT_FUNCTIONS и MAIN_FUNCTIONS
# SRC=$(wildcard $(PATH_TO_SUP)*.cc) $(wildcard $(PATH_TO_MAIN)*.cc)

# # Список всех .о файлов в папках objects/SUPPORT_FUNCTIONS и objects/MAIN_FUNCTIONS
# OBJ=$(patsubst %.cc, $(PATH_TO_OBJ)%.o, $(SRC))

# # Список .cc файлов автотестов с путём (TESTS/s21_list_test.cc ...)
# SRC_T=$(wildcard $(PATH_TO_TESTS)*.cc)

# # Список .o файлов автотестов c путём в папку объектов 
# # (Функция patsubst берет список всех .сс файлов из папки TESTS, 
# #  подменяет их расширения на .о и добавляет спереди каждому папку objects/ 
# #  и получается список: objects/TESTS/s21_list_test.o ...)
# OBJ_T=$(patsubst %.cc, $(PATH_TO_OBJ)%.o, $(SRC_T))



# ###############################################################################
# ##                                                                           ##
# ##                      О С Н О В Н Ы Е   Ц Е Л И                            ##
# ##                                                                           ##
# ###############################################################################
   								
# # ╔═════════════════════════════════════════════════════════════════════════╗
# # ║ Комплексная цель all                                                    ║
# # ╚═════════════════════════════════════════════════════════════════════════╝
# all: $(LIB_NAME) test gcov_report
# 	@echo "\n$(BRIGHT_ORANGE) $(STAR) Все цели выполнены $(STAR)  $(RESET)\n"


# # ╔═════════════════════════════════════════════════════════════════════════╗
# # ║ Создание статической библиотеки                                         ║
# # ╚═════════════════════════════════════════════════════════════════════════╝
# $(LIB_NAME): $(OBJ)
# 	@echo "\n $(WHITE)$(ARROW) Создание статической библиотеки...$(RESET)"
# 	@ar rcs $@ $(OBJ)
# # @ranlib $@
# 	@echo "$(BLACK_WHITE) $(CHECK) Библиотека s21_containers.a создана $(RESET)\n"


# # ╔═════════════════════════════════════════════════════════════════════════╗
# # ║ Запуск тестов                                                           ║
# # ╚═════════════════════════════════════════════════════════════════════════╝
# test: $(OBJ_T) $(LIB_NAME)
# 	@echo "\n$(GREEN)$(ARROW) Запуск тестов...$(RESET)\n"
# # ifeq ($(OS), Darwin)
# 	@$(CXX) $(CFLAGS) $(OBJ_T) $(LIB_NAME) $(LIBS) -o $(PATH_TO_TESTS)$(EXEC_T)
# # else ifeq ($(OS), Linux)
# # 	@$(CXX) $(CFLAGS) $(OBJ_T) $(LIB_NAME) $(LIBS) -o $(PATH_TO_TESTS)$(EXEC_T)
# # -lsubunit
# # -lrt -lm
# # endif
# 	@$(PATH_TO_TESTS)./$(EXEC_T)
# # | tee $(PATH_TO_TESTS)$(EXEC_T).txt
# 	@echo "\n$(GREEN) $(CHECK) Тесты завершены  $(RESET)\n" 
# # @echo "$(GREEN)   Файл тестов находится по адресу '$(PATH_TO_TESTS)$(EXEC_T).txt' $(RESET)\n"


# # ╔═════════════════════════════════════════════════════════════════════════╗
# # ║ Создание отчета покрытия gcov. Тесты исключаются                        ║
# # ╚═════════════════════════════════════════════════════════════════════════╝
# # 				установка: pip install git+https://github.com/gcovr/gcovr.git
# #
# gcov_report:
# 	@echo " \n $(BLUE)  Создание отчета покрытия...$(RESET)"
# 	@gcovr $(GCR) \
# 	--html-details $(COV_REPORT)gcov_report.html \
# 	--html-theme github.dark-blue \
# 	--exclude "$(PATH_TO_TESTS)*" \
# 	--html-template ./gcovr_template.html \
# 	> /dev/null 2>&1
# # --decisions
# 	@echo "$(BLUE) $(CHECK) Отчет покрытия создан $(RESET)\n"
# 	@if command -v xdg-open > /dev/null; then \
#         xdg-open $(COV_REPORT)gcov_report.html; \
#     elif command -v open > /dev/null; then \
#         open $(COV_REPORT)gcov_report.html; \
#     else \
#         echo "Не удалось открыть браузер. Пожалуйста, откройте '$(COV_REPORT)gcov_report.html' вручную."; \
#     fi

# dvi:
# 	doxygen doxyconfig
# 	open ./html/index.html

# # ╔═════════════════════════════════════════════════════════════════════════╗
# # ║ Удаление библиотеки и директорий objects/ REPORT/                       ║
# # ╚═════════════════════════════════════════════════════════════════════════╝
# clean:
# 	@echo "\n$(RED_ALERT)   Очистка...$(RESET)"
# 	@rm -rf \
# 	$(PATH_TO_OBJ) \
# 	$(COV_REPORT) \
# 	$(PATH_TO_TESTS)./$(EXEC_T)* \
# 	$(LIB_NAME)
# 	@echo "$(RED_ALERT) $(CHECK) Очистка завершена $(RESET)\n"



# ###############################################################################
# ##                                                                           ##
# ##                  С Л У Ж Е Б Н Ы Е    О П Е Р А Ц И И                     ##
# ##                                                                           ##
# ###############################################################################

# # ╔═════════════════════════════════════════════════════════════════════════╗
# # ║ Служебная цель. Компиляция объектных файлов                             ║
# # ╚═════════════════════════════════════════════════════════════════════════╝
# $(PATH_TO_OBJ)%.o: %.cc
# 	@echo "$(GREY)  $<...$(RESET)"
# 	@$(CXX) $(CFLAGS) -c $< -o $@
# 	@echo "$(WHITE)$(CHECK) $@$(RESET)"

# # ╔═════════════════════════════════════════════════════════════════════════╗
# # ║ Создание директорий объектов.                                           ║
# # ║ Служебная команда, выполняемая всегда.                                  ║
# # ╚═════════════════════════════════════════════════════════════════════════╝ 
# $(shell \
# 	mkdir -p $(COV_REPORT) \
# 			 $(PATH_TO_OBJ)$(PATH_TO_TESTS) \
# 			 $(PATH_TO_OBJ)$(PATH_TO_SUP) \
# 			 $(PATH_TO_OBJ)$(PATH_TO_MAIN))

# .PHONY: all gcov_report dvi test clean $(LIB_NAME)

# include MAKEFILES/develop.mk
# include MAKEFILES/git.mk
# include MAKEFILES/clearmac.mk

# # V_COMMAND=valgrind  --tool=memcheck --track-fds=yes --trace-children=yes --track-origins=yes --leak-check=full --show-leak-kinds=all -s
# # L_COMMAND=leaks -atExit --

# # ANSI escape-коды для цветов
# GREY = \033[38;05;242m
# RED_ALERT = \033[0;91m
# BLACK_WHITE = \033[01;38;05;232;48;05;253m
# BRIGHT_ORANGE = \033[01;38;05;232;48;05;214m
# BLUE = \033[38;05;68m
# WHITE = \033[37m
# RESET = \033[0m
# GREEN = \033[38;05;35m

# # Символьная графика
# ARROW = ➔
# STAR = ★
# CHECK = ✔
# # FULL = ●
# # EMPTY = ○
